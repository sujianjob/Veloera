# Veloera éŸ³è§†é¢‘è½¬å½•æœåŠ¡æ”¹é€ æ–¹æ¡ˆ

## ğŸ¯ æ”¹é€ ç­–ç•¥æ¦‚è§ˆ

### æ ¸å¿ƒæ€è·¯
ä¿ç•™ Veloera çš„ï¼š
- âœ… ç”¨æˆ·ç®¡ç†ç³»ç»Ÿ (users, tokens è¡¨)
- âœ… è®¡è´¹ä¸é…é¢ç³»ç»Ÿ (quota_data, topups è¡¨)
- âœ… æƒé™æ§åˆ¶ (roles, permissions)
- âœ… æ—¥å¿—ç›‘æ§ (logs è¡¨)
- âœ… Web ç®¡ç†ç•Œé¢

æ›¿æ¢ AI ä¸­è½¬åŠŸèƒ½ä¸ºï¼š
- ğŸ”„ éŸ³è§†é¢‘æ–‡ä»¶ä¸Šä¼ å¤„ç†
- ğŸ”„ å¤šç§è½¬å½•å¼•æ“é€‚é… (æ›¿æ¢ AI æœåŠ¡å•†é€‚é…å™¨)
- ğŸ”„ è½¬å½•ä»»åŠ¡ç®¡ç† (æ›¿æ¢ AI è¯·æ±‚ç®¡ç†)
- ğŸ”„ ç»“æœå­˜å‚¨ä¸ä¸‹è½½

## ğŸ“‹ è¯¦ç»†æ”¹é€ æ–¹æ¡ˆ

### 1. æ•°æ®åº“æ¨¡å‹è°ƒæ•´

#### 1.1 æ–°å¢è½¬å½•ç›¸å…³è¡¨

```sql
-- è½¬å½•ä»»åŠ¡è¡¨ (æ›¿æ¢åŸæ¥çš„ midjourney/task è¡¨)
CREATE TABLE transcription_tasks (
    id                  BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id             INT NOT NULL,                   -- ç”¨æˆ·ID
    token_id            INT,                            -- ä½¿ç”¨çš„Token ID
    channel_id          INT NOT NULL,                   -- è½¬å½•å¼•æ“æ¸ é“ID
    
    -- æ–‡ä»¶ä¿¡æ¯
    original_filename   VARCHAR(255) NOT NULL,          -- åŸå§‹æ–‡ä»¶å
    file_path           VARCHAR(512) NOT NULL,          -- æ–‡ä»¶å­˜å‚¨è·¯å¾„
    file_size           BIGINT NOT NULL,                -- æ–‡ä»¶å¤§å°(å­—èŠ‚)
    file_type           VARCHAR(50) NOT NULL,           -- æ–‡ä»¶ç±»å‹(mp3,mp4,wavç­‰)
    duration            INT,                            -- éŸ³è§†é¢‘æ—¶é•¿(ç§’)
    
    -- è½¬å½•é…ç½®
    language            VARCHAR(10) DEFAULT 'auto',     -- è¯­è¨€ä»£ç (zh,en,autoç­‰)
    model_name          VARCHAR(100),                   -- ä½¿ç”¨çš„æ¨¡å‹
    enable_timestamps   BOOLEAN DEFAULT TRUE,           -- æ˜¯å¦åŒ…å«æ—¶é—´æˆ³
    enable_speaker      BOOLEAN DEFAULT FALSE,          -- æ˜¯å¦è¯†åˆ«è¯´è¯äºº
    output_format       VARCHAR(20) DEFAULT 'json',     -- è¾“å‡ºæ ¼å¼(json,srt,txtç­‰)
    
    -- ä»»åŠ¡çŠ¶æ€
    status              VARCHAR(20) DEFAULT 'pending',  -- pending,processing,completed,failed
    progress            INT DEFAULT 0,                  -- è¿›åº¦ç™¾åˆ†æ¯”
    error_message       TEXT,                           -- é”™è¯¯ä¿¡æ¯
    
    -- ç»“æœä¿¡æ¯
    result_text         LONGTEXT,                       -- è½¬å½•æ–‡æœ¬ç»“æœ
    result_file_path    VARCHAR(512),                   -- ç»“æœæ–‡ä»¶è·¯å¾„
    confidence_score    DECIMAL(3,2),                   -- ç½®ä¿¡åº¦åˆ†æ•°
    
    -- è®¡è´¹ä¿¡æ¯
    quota_cost          INT DEFAULT 0,                  -- æ¶ˆè€—çš„é…é¢
    billing_duration    INT,                            -- è®¡è´¹æ—¶é•¿(ç§’)
    
    -- æ—¶é—´æˆ³
    created_at          TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    started_at          TIMESTAMP NULL,                 -- å¼€å§‹å¤„ç†æ—¶é—´
    completed_at        TIMESTAMP NULL,                 -- å®Œæˆæ—¶é—´
    updated_at          TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_user_id (user_id),
    INDEX idx_token_id (token_id),
    INDEX idx_channel_id (channel_id),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
);

-- æ–‡ä»¶å­˜å‚¨è¡¨
CREATE TABLE file_storage (
    id              BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id         INT NOT NULL,
    task_id         BIGINT,                             -- å…³è”çš„è½¬å½•ä»»åŠ¡ID
    file_type       VARCHAR(20) NOT NULL,               -- original, result
    original_name   VARCHAR(255) NOT NULL,              -- åŸå§‹æ–‡ä»¶å
    stored_name     VARCHAR(255) NOT NULL,              -- å­˜å‚¨æ–‡ä»¶å
    file_path       VARCHAR(512) NOT NULL,              -- æ–‡ä»¶è·¯å¾„
    file_size       BIGINT NOT NULL,                    -- æ–‡ä»¶å¤§å°
    mime_type       VARCHAR(100),                       -- MIMEç±»å‹
    expires_at      TIMESTAMP NULL,                     -- è¿‡æœŸæ—¶é—´
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_user_id (user_id),
    INDEX idx_task_id (task_id),
    INDEX idx_file_type (file_type),
    INDEX idx_expires_at (expires_at)
);
```

#### 1.2 è°ƒæ•´ç°æœ‰è¡¨

```sql
-- è°ƒæ•´ channels è¡¨ï¼Œæ”¹ä¸ºè½¬å½•å¼•æ“é…ç½®
ALTER TABLE channels MODIFY COLUMN type INT COMMENT 'è½¬å½•å¼•æ“ç±»å‹: 1=é˜¿é‡Œäº‘, 2=è…¾è®¯äº‘, 3=ç™¾åº¦äº‘, 4=è®¯é£, 5=Azure, 6=AWS, 7=Google, 8=OpenAI Whisper';
ALTER TABLE channels MODIFY COLUMN models TEXT COMMENT 'æ”¯æŒçš„è¯­è¨€åˆ—è¡¨: zh,en,ja,koç­‰';
ALTER TABLE channels ADD COLUMN max_file_size BIGINT DEFAULT 104857600 COMMENT 'æœ€å¤§æ–‡ä»¶å¤§å°(å­—èŠ‚)';
ALTER TABLE channels ADD COLUMN supported_formats VARCHAR(255) DEFAULT 'mp3,mp4,wav,m4a,flac' COMMENT 'æ”¯æŒçš„æ–‡ä»¶æ ¼å¼';
ALTER TABLE channels ADD COLUMN max_duration INT DEFAULT 3600 COMMENT 'æœ€å¤§æ—¶é•¿(ç§’)';

-- è°ƒæ•´ logs è¡¨ï¼Œé€‚é…è½¬å½•æœåŠ¡
ALTER TABLE logs ADD COLUMN file_size BIGINT COMMENT 'å¤„ç†çš„æ–‡ä»¶å¤§å°';
ALTER TABLE logs ADD COLUMN duration INT COMMENT 'éŸ³è§†é¢‘æ—¶é•¿';
ALTER TABLE logs MODIFY COLUMN model_name VARCHAR(255) COMMENT 'è½¬å½•å¼•æ“/æ¨¡å‹åç§°';

-- è°ƒæ•´ quota_data è¡¨
ALTER TABLE quota_data ADD COLUMN file_count INT DEFAULT 0 COMMENT 'å¤„ç†æ–‡ä»¶æ•°é‡';
ALTER TABLE quota_data ADD COLUMN total_duration INT DEFAULT 0 COMMENT 'æ€»å¤„ç†æ—¶é•¿';
```

### 2. è½¬å½•å¼•æ“ç±»å‹å®šä¹‰

```go
// constant/transcription_engine.go
package constant

const (
    EngineTypeAliCloud    = 1  // é˜¿é‡Œäº‘è¯­éŸ³è¯†åˆ«
    EngineTypeTencent     = 2  // è…¾è®¯äº‘è¯­éŸ³è¯†åˆ«
    EngineTypeBaidu       = 3  // ç™¾åº¦è¯­éŸ³è¯†åˆ«
    EngineTypeXunfei      = 4  // è®¯é£è¯­éŸ³è¯†åˆ«
    EngineTypeAzure       = 5  // Azure Speech Services
    EngineTypeAWS         = 6  // AWS Transcribe
    EngineTypeGoogle      = 7  // Google Speech-to-Text
    EngineTypeWhisper     = 8  // OpenAI Whisper
    EngineTypeLocal       = 9  // æœ¬åœ°éƒ¨ç½²å¼•æ“
)

var EngineNames = map[int]string{
    EngineTypeAliCloud: "é˜¿é‡Œäº‘è¯­éŸ³è¯†åˆ«",
    EngineTypeTencent:  "è…¾è®¯äº‘è¯­éŸ³è¯†åˆ«",
    EngineTypeBaidu:    "ç™¾åº¦è¯­éŸ³è¯†åˆ«",
    EngineTypeXunfei:   "è®¯é£è¯­éŸ³è¯†åˆ«",
    EngineTypeAzure:    "Azure Speech Services",
    EngineTypeAWS:      "AWS Transcribe",
    EngineTypeGoogle:   "Google Speech-to-Text",
    EngineTypeWhisper:  "OpenAI Whisper",
    EngineTypeLocal:    "æœ¬åœ°éƒ¨ç½²å¼•æ“",
}

// æ”¯æŒçš„æ–‡ä»¶æ ¼å¼
var SupportedFormats = []string{
    "mp3", "mp4", "wav", "m4a", "flac", "aac", "ogg", "wma",
}

// æ”¯æŒçš„è¯­è¨€
var SupportedLanguages = map[string]string{
    "auto": "è‡ªåŠ¨æ£€æµ‹",
    "zh":   "ä¸­æ–‡",
    "en":   "è‹±è¯­",
    "ja":   "æ—¥è¯­",
    "ko":   "éŸ©è¯­",
    "es":   "è¥¿ç­ç‰™è¯­",
    "fr":   "æ³•è¯­",
    "de":   "å¾·è¯­",
    "ru":   "ä¿„è¯­",
}
```

### 3. æ ¸å¿ƒä¸šåŠ¡é€»è¾‘

#### 3.1 è½¬å½•ä»»åŠ¡æ¨¡å‹

```go
// model/transcription.go
package model

import (
    "time"
    "gorm.io/gorm"
)

type TranscriptionTask struct {
    ID                 int64     `json:"id" gorm:"primaryKey"`
    UserID             int       `json:"user_id" gorm:"not null;index"`
    TokenID            *int      `json:"token_id" gorm:"index"`
    ChannelID          int       `json:"channel_id" gorm:"not null;index"`
    
    // æ–‡ä»¶ä¿¡æ¯
    OriginalFilename   string    `json:"original_filename" gorm:"not null"`
    FilePath           string    `json:"file_path" gorm:"not null"`
    FileSize           int64     `json:"file_size" gorm:"not null"`
    FileType           string    `json:"file_type" gorm:"not null"`
    Duration           *int      `json:"duration"`
    
    // è½¬å½•é…ç½®
    Language           string    `json:"language" gorm:"default:'auto'"`
    ModelName          string    `json:"model_name"`
    EnableTimestamps   bool      `json:"enable_timestamps" gorm:"default:true"`
    EnableSpeaker      bool      `json:"enable_speaker" gorm:"default:false"`
    OutputFormat       string    `json:"output_format" gorm:"default:'json'"`
    
    // ä»»åŠ¡çŠ¶æ€
    Status             string    `json:"status" gorm:"default:'pending';index"`
    Progress           int       `json:"progress" gorm:"default:0"`
    ErrorMessage       string    `json:"error_message"`
    
    // ç»“æœä¿¡æ¯
    ResultText         string    `json:"result_text" gorm:"type:longtext"`
    ResultFilePath     string    `json:"result_file_path"`
    ConfidenceScore    *float64  `json:"confidence_score"`
    
    // è®¡è´¹ä¿¡æ¯
    QuotaCost          int       `json:"quota_cost" gorm:"default:0"`
    BillingDuration    *int      `json:"billing_duration"`
    
    // æ—¶é—´æˆ³
    CreatedAt          time.Time  `json:"created_at"`
    StartedAt          *time.Time `json:"started_at"`
    CompletedAt        *time.Time `json:"completed_at"`
    UpdatedAt          time.Time  `json:"updated_at"`
}

// ä»»åŠ¡çŠ¶æ€å¸¸é‡
const (
    TaskStatusPending    = "pending"
    TaskStatusProcessing = "processing"
    TaskStatusCompleted  = "completed"
    TaskStatusFailed     = "failed"
)

// è¾“å‡ºæ ¼å¼å¸¸é‡
const (
    OutputFormatJSON = "json"
    OutputFormatSRT  = "srt"
    OutputFormatTXT  = "txt"
    OutputFormatVTT  = "vtt"
)
```

#### 3.2 è½¬å½•å¼•æ“é€‚é…å™¨æ¥å£

```go
// service/transcription/adaptor.go
package transcription

import (
    "context"
    "io"
    "veloera/model"
)

// TranscriptionAdaptor è½¬å½•å¼•æ“é€‚é…å™¨æ¥å£
type TranscriptionAdaptor interface {
    // è·å–å¼•æ“åç§°
    GetEngineName() string
    
    // è·å–æ”¯æŒçš„æ–‡ä»¶æ ¼å¼
    GetSupportedFormats() []string
    
    // è·å–æ”¯æŒçš„è¯­è¨€
    GetSupportedLanguages() []string
    
    // è·å–æœ€å¤§æ–‡ä»¶å¤§å°é™åˆ¶
    GetMaxFileSize() int64
    
    // è·å–æœ€å¤§æ—¶é•¿é™åˆ¶
    GetMaxDuration() int
    
    // éªŒè¯æ–‡ä»¶æ˜¯å¦ç¬¦åˆè¦æ±‚
    ValidateFile(filePath string, fileSize int64, duration int) error
    
    // æäº¤è½¬å½•ä»»åŠ¡
    SubmitTask(ctx context.Context, task *model.TranscriptionTask, fileReader io.Reader) error
    
    // æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€
    QueryTaskStatus(ctx context.Context, task *model.TranscriptionTask) error
    
    // è·å–è½¬å½•ç»“æœ
    GetResult(ctx context.Context, task *model.TranscriptionTask) (*TranscriptionResult, error)
    
    // å–æ¶ˆä»»åŠ¡
    CancelTask(ctx context.Context, task *model.TranscriptionTask) error
}

// TranscriptionResult è½¬å½•ç»“æœ
type TranscriptionResult struct {
    Text            string                 `json:"text"`
    Segments        []TranscriptionSegment `json:"segments,omitempty"`
    Language        string                 `json:"language"`
    Duration        float64                `json:"duration"`
    ConfidenceScore float64                `json:"confidence_score"`
}

// TranscriptionSegment è½¬å½•ç‰‡æ®µ
type TranscriptionSegment struct {
    ID              int     `json:"id"`
    Start           float64 `json:"start"`
    End             float64 `json:"end"`
    Text            string  `json:"text"`
    Speaker         string  `json:"speaker,omitempty"`
    Confidence      float64 `json:"confidence"`
}
```

### 4. å…·ä½“è½¬å½•å¼•æ“å®ç°ç¤ºä¾‹

#### 4.1 OpenAI Whisper é€‚é…å™¨

```go
// service/transcription/whisper/adaptor.go
package whisper

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "io"
    "mime/multipart"
    "net/http"
    "veloera/model"
    "veloera/service/transcription"
)

type WhisperAdaptor struct {
    APIKey  string
    BaseURL string
}

func (w *WhisperAdaptor) GetEngineName() string {
    return "OpenAI Whisper"
}

func (w *WhisperAdaptor) GetSupportedFormats() []string {
    return []string{"mp3", "mp4", "wav", "m4a", "flac"}
}

func (w *WhisperAdaptor) GetSupportedLanguages() []string {
    return []string{"auto", "zh", "en", "ja", "ko", "es", "fr", "de", "ru"}
}

func (w *WhisperAdaptor) GetMaxFileSize() int64 {
    return 25 * 1024 * 1024 // 25MB
}

func (w *WhisperAdaptor) GetMaxDuration() int {
    return 3600 // 1å°æ—¶
}

func (w *WhisperAdaptor) SubmitTask(ctx context.Context, task *model.TranscriptionTask, fileReader io.Reader) error {
    // åˆ›å»ºmultipartè¡¨å•
    var buf bytes.Buffer
    writer := multipart.NewWriter(&buf)

    // æ·»åŠ æ–‡ä»¶
    fileWriter, err := writer.CreateFormFile("file", task.OriginalFilename)
    if err != nil {
        return err
    }

    if _, err := io.Copy(fileWriter, fileReader); err != nil {
        return err
    }

    // æ·»åŠ å…¶ä»–å‚æ•°
    writer.WriteField("model", "whisper-1")
    if task.Language != "auto" {
        writer.WriteField("language", task.Language)
    }
    if task.EnableTimestamps {
        writer.WriteField("timestamp_granularities[]", "segment")
    }
    writer.WriteField("response_format", "verbose_json")

    writer.Close()

    // å‘é€è¯·æ±‚
    req, err := http.NewRequestWithContext(ctx, "POST", w.BaseURL+"/v1/audio/transcriptions", &buf)
    if err != nil {
        return err
    }

    req.Header.Set("Authorization", "Bearer "+w.APIKey)
    req.Header.Set("Content-Type", writer.FormDataContentType())

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("API request failed with status: %d", resp.StatusCode)
    }

    // è§£æå“åº”
    var result WhisperResponse
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return err
    }

    // æ›´æ–°ä»»åŠ¡çŠ¶æ€
    task.Status = model.TaskStatusCompleted
    task.ResultText = result.Text
    task.Progress = 100

    if len(result.Segments) > 0 {
        task.ConfidenceScore = &result.Segments[0].AvgLogprob
    }

    return nil
}

type WhisperResponse struct {
    Text     string           `json:"text"`
    Language string           `json:"language"`
    Duration float64          `json:"duration"`
    Segments []WhisperSegment `json:"segments"`
}

type WhisperSegment struct {
    ID         int     `json:"id"`
    Start      float64 `json:"start"`
    End        float64 `json:"end"`
    Text       string  `json:"text"`
    AvgLogprob float64 `json:"avg_logprob"`
}
```

#### 4.2 é˜¿é‡Œäº‘è¯­éŸ³è¯†åˆ«é€‚é…å™¨

```go
// service/transcription/alicloud/adaptor.go
package alicloud

import (
    "context"
    "encoding/json"
    "fmt"
    "io"
    "veloera/model"
    "veloera/service/transcription"

    "github.com/aliyun/alibaba-cloud-sdk-go/services/nls"
)

type AliCloudAdaptor struct {
    AccessKeyID     string
    AccessKeySecret string
    Region          string
}

func (a *AliCloudAdaptor) GetEngineName() string {
    return "é˜¿é‡Œäº‘è¯­éŸ³è¯†åˆ«"
}

func (a *AliCloudAdaptor) GetSupportedFormats() []string {
    return []string{"wav", "mp3", "aac", "flac"}
}

func (a *AliCloudAdaptor) GetSupportedLanguages() []string {
    return []string{"zh", "en", "ja", "ko"}
}

func (a *AliCloudAdaptor) GetMaxFileSize() int64 {
    return 512 * 1024 * 1024 // 512MB
}

func (a *AliCloudAdaptor) GetMaxDuration() int {
    return 14400 // 4å°æ—¶
}

func (a *AliCloudAdaptor) SubmitTask(ctx context.Context, task *model.TranscriptionTask, fileReader io.Reader) error {
    // å®ç°é˜¿é‡Œäº‘è¯­éŸ³è¯†åˆ«APIè°ƒç”¨
    // è¿™é‡Œéœ€è¦æ ¹æ®é˜¿é‡Œäº‘SDKå®ç°å…·ä½“é€»è¾‘

    // 1. ä¸Šä¼ æ–‡ä»¶åˆ°OSS
    // 2. æäº¤è½¬å½•ä»»åŠ¡
    // 3. è½®è¯¢ä»»åŠ¡çŠ¶æ€
    // 4. è·å–ç»“æœ

    return nil
}

// å…¶ä»–æ–¹æ³•å®ç°...
```

### 5. API æ¥å£è®¾è®¡

#### 5.1 è½¬å½•ä»»åŠ¡ç›¸å…³æ¥å£

```go
// controller/transcription.go
package controller

import (
    "net/http"
    "strconv"
    "veloera/model"
    "veloera/service"

    "github.com/gin-gonic/gin"
)

// ä¸Šä¼ æ–‡ä»¶å¹¶åˆ›å»ºè½¬å½•ä»»åŠ¡
func CreateTranscriptionTask(c *gin.Context) {
    userID := c.GetInt("id")
    tokenID := c.GetInt("token_id")

    // è·å–ä¸Šä¼ çš„æ–‡ä»¶
    file, header, err := c.Request.FormFile("file")
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "æ–‡ä»¶ä¸Šä¼ å¤±è´¥"})
        return
    }
    defer file.Close()

    // è·å–è½¬å½•å‚æ•°
    language := c.DefaultPostForm("language", "auto")
    enableTimestamps := c.DefaultPostForm("enable_timestamps", "true") == "true"
    enableSpeaker := c.DefaultPostForm("enable_speaker", "false") == "true"
    outputFormat := c.DefaultPostForm("output_format", "json")

    // éªŒè¯æ–‡ä»¶æ ¼å¼å’Œå¤§å°
    if !service.IsValidAudioFile(header.Filename) {
        c.JSON(http.StatusBadRequest, gin.H{"error": "ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼"})
        return
    }

    if header.Size > service.GetMaxFileSize() {
        c.JSON(http.StatusBadRequest, gin.H{"error": "æ–‡ä»¶å¤§å°è¶…å‡ºé™åˆ¶"})
        return
    }

    // æ£€æŸ¥ç”¨æˆ·é…é¢
    if !service.CheckUserQuota(userID, header.Size) {
        c.JSON(http.StatusForbidden, gin.H{"error": "é…é¢ä¸è¶³"})
        return
    }

    // åˆ›å»ºè½¬å½•ä»»åŠ¡
    task := &model.TranscriptionTask{
        UserID:           userID,
        TokenID:          &tokenID,
        OriginalFilename: header.Filename,
        FileSize:         header.Size,
        Language:         language,
        EnableTimestamps: enableTimestamps,
        EnableSpeaker:    enableSpeaker,
        OutputFormat:     outputFormat,
        Status:           model.TaskStatusPending,
    }

    // ä¿å­˜æ–‡ä»¶å¹¶æäº¤ä»»åŠ¡
    if err := service.ProcessTranscriptionTask(task, file); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "success": true,
        "data":    task,
    })
}

// è·å–è½¬å½•ä»»åŠ¡çŠ¶æ€
func GetTranscriptionTask(c *gin.Context) {
    taskID, err := strconv.ParseInt(c.Param("id"), 10, 64)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "æ— æ•ˆçš„ä»»åŠ¡ID"})
        return
    }

    userID := c.GetInt("id")

    task, err := service.GetTranscriptionTask(taskID, userID)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "ä»»åŠ¡ä¸å­˜åœ¨"})
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "success": true,
        "data":    task,
    })
}

// è·å–ç”¨æˆ·çš„è½¬å½•ä»»åŠ¡åˆ—è¡¨
func GetUserTranscriptionTasks(c *gin.Context) {
    userID := c.GetInt("id")
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "20"))
    status := c.Query("status")

    tasks, total, err := service.GetUserTranscriptionTasks(userID, page, pageSize, status)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "success": true,
        "data": gin.H{
            "tasks": tasks,
            "total": total,
            "page":  page,
            "page_size": pageSize,
        },
    })
}

// ä¸‹è½½è½¬å½•ç»“æœ
func DownloadTranscriptionResult(c *gin.Context) {
    taskID, err := strconv.ParseInt(c.Param("id"), 10, 64)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "æ— æ•ˆçš„ä»»åŠ¡ID"})
        return
    }

    userID := c.GetInt("id")
    format := c.DefaultQuery("format", "json")

    filePath, filename, err := service.GetTranscriptionResultFile(taskID, userID, format)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
        return
    }

    c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=%s", filename))
    c.File(filePath)
}
```

### 6. å‰ç«¯ç•Œé¢è°ƒæ•´

#### 6.1 ä¸»è¦é¡µé¢æ”¹é€ 

1. **é¦–é¡µ** - æ”¹ä¸ºè½¬å½•æœåŠ¡ä»‹ç»
2. **ä¸Šä¼ é¡µé¢** - æ–‡ä»¶ä¸Šä¼ å’Œè½¬å½•å‚æ•°è®¾ç½®
3. **ä»»åŠ¡åˆ—è¡¨** - æ˜¾ç¤ºè½¬å½•ä»»åŠ¡çŠ¶æ€å’Œè¿›åº¦
4. **ç»“æœé¡µé¢** - æ˜¾ç¤ºè½¬å½•ç»“æœå’Œä¸‹è½½é“¾æ¥
5. **ç®¡ç†åå°** - è½¬å½•å¼•æ“ç®¡ç†ã€ç”¨æˆ·ç®¡ç†ã€ç»Ÿè®¡åˆ†æ

#### 6.2 æ ¸å¿ƒç»„ä»¶ç¤ºä¾‹

```jsx
// æ–‡ä»¶ä¸Šä¼ ç»„ä»¶
const TranscriptionUpload = () => {
  const [file, setFile] = useState(null);
  const [language, setLanguage] = useState('auto');
  const [enableTimestamps, setEnableTimestamps] = useState(true);
  const [outputFormat, setOutputFormat] = useState('json');
  const [uploading, setUploading] = useState(false);

  const handleUpload = async () => {
    if (!file) return;

    setUploading(true);
    const formData = new FormData();
    formData.append('file', file);
    formData.append('language', language);
    formData.append('enable_timestamps', enableTimestamps);
    formData.append('output_format', outputFormat);

    try {
      const response = await api.post('/api/transcription/tasks', formData);
      // å¤„ç†æˆåŠŸå“åº”
    } catch (error) {
      // å¤„ç†é”™è¯¯
    } finally {
      setUploading(false);
    }
  };

  return (
    <div className="upload-container">
      <input
        type="file"
        accept="audio/*,video/*"
        onChange={(e) => setFile(e.target.files[0])}
      />

      <select value={language} onChange={(e) => setLanguage(e.target.value)}>
        <option value="auto">è‡ªåŠ¨æ£€æµ‹</option>
        <option value="zh">ä¸­æ–‡</option>
        <option value="en">è‹±è¯­</option>
      </select>

      <label>
        <input
          type="checkbox"
          checked={enableTimestamps}
          onChange={(e) => setEnableTimestamps(e.target.checked)}
        />
        åŒ…å«æ—¶é—´æˆ³
      </label>

      <button onClick={handleUpload} disabled={!file || uploading}>
        {uploading ? 'ä¸Šä¼ ä¸­...' : 'å¼€å§‹è½¬å½•'}
      </button>
    </div>
  );
};
```

### 7. è®¡è´¹æ¨¡å¼è°ƒæ•´

#### 7.1 è½¬å½•æœåŠ¡è®¡è´¹æ–¹æ¡ˆ

```go
// service/billing.go
package service

// è½¬å½•è®¡è´¹ç­–ç•¥
type TranscriptionBilling struct {
    // æŒ‰æ—¶é•¿è®¡è´¹ (å…ƒ/åˆ†é’Ÿ)
    PricePerMinute float64

    // æŒ‰æ–‡ä»¶å¤§å°è®¡è´¹ (å…ƒ/MB)
    PricePerMB float64

    // æŒ‰å­—ç¬¦æ•°è®¡è´¹ (å…ƒ/åƒå­—ç¬¦)
    PricePerKChar float64

    // ä¸åŒå¼•æ“çš„å€ç‡
    EngineMultiplier map[int]float64

    // ä¸åŒè¯­è¨€çš„å€ç‡
    LanguageMultiplier map[string]float64
}

// è®¡ç®—è½¬å½•è´¹ç”¨
func CalculateTranscriptionCost(task *model.TranscriptionTask, billing *TranscriptionBilling) int {
    baseCost := 0.0

    // æŒ‰æ—¶é•¿è®¡è´¹
    if task.Duration != nil {
        minutes := float64(*task.Duration) / 60.0
        baseCost += minutes * billing.PricePerMinute
    }

    // åº”ç”¨å¼•æ“å€ç‡
    if multiplier, exists := billing.EngineMultiplier[task.ChannelID]; exists {
        baseCost *= multiplier
    }

    // åº”ç”¨è¯­è¨€å€ç‡
    if multiplier, exists := billing.LanguageMultiplier[task.Language]; exists {
        baseCost *= multiplier
    }

    // è½¬æ¢ä¸ºé…é¢å•ä½ (å‡è®¾1å…ƒ=1000é…é¢)
    return int(baseCost * 1000)
}
```

### 8. éƒ¨ç½²å’Œé…ç½®

#### 8.1 ç¯å¢ƒå˜é‡é…ç½®

```bash
# è½¬å½•æœåŠ¡é…ç½®
TRANSCRIPTION_STORAGE_PATH=/data/transcription
TRANSCRIPTION_MAX_FILE_SIZE=104857600  # 100MB
TRANSCRIPTION_MAX_DURATION=3600        # 1å°æ—¶
TRANSCRIPTION_RESULT_EXPIRE_DAYS=30    # ç»“æœä¿å­˜30å¤©

# è½¬å½•å¼•æ“é…ç½®
WHISPER_API_KEY=your_openai_api_key
WHISPER_BASE_URL=https://api.openai.com

ALICLOUD_ACCESS_KEY_ID=your_access_key_id
ALICLOUD_ACCESS_KEY_SECRET=your_access_key_secret
ALICLOUD_REGION=cn-hangzhou

# æ–‡ä»¶å­˜å‚¨é…ç½®
FILE_STORAGE_TYPE=local  # local, oss, s3
OSS_BUCKET=your_bucket_name
OSS_ENDPOINT=oss-cn-hangzhou.aliyuncs.com
```

è¿™ä¸ªæ”¹é€ æ–¹æ¡ˆä¿ç•™äº† Veloera çš„æ‰€æœ‰ä¼˜ç§€åŸºç¡€è®¾æ–½ï¼Œåªéœ€è¦æ›¿æ¢æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼Œå°±èƒ½å¿«é€Ÿæ„å»ºä¸€ä¸ªåŠŸèƒ½å®Œå–„çš„éŸ³è§†é¢‘è½¬å½•æœåŠ¡å¹³å°ã€‚
```
